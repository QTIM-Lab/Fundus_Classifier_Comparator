<!-- TEMPLATE -->
{% extends "vuetify_components/base.html" %}

<!-- TITLE -->
{% block title %}Image Classifier{% endblock %}

<!-- CSS -->
{% block custom_css %}
<style>
  canvas {
    width: 100%;
    height: auto;
  }

  .parent {
    position: relative;
    top: 0;
    left: 0;
    background-color: rgb(255, 255, 255);
    width: 700px;
    height: 700px;
    border: 1px;
    border-style: dashed;
    /* new */
    /* display: flex; */
    /* align-items: center; */
    /* justify-content: center; */
    
  }
  
  .image {
    position: relative;
    top: 0;
    left: 0;
    display: block;
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
    /* Preserve aspect ratio while fitting */
    /* object-fit: contain; */ /* or object-fit: cover; depending on your preference */
  }
  
  .segmentation {
    position: absolute;
    top: 0px;
    left: 0px;
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
  }

  .coco {
    position: absolute;
    top: 0px;
    left: 0px;
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
  }

  .spinner {
    display: inline-block; /* Add this line */
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    animation: spin 1s linear infinite;
  }

  .spinner-inner {
    width: 8px;
    height: 8px;
    border: 4px solid transparent;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    position: absolute;
    top: 0px;
    left: 0px;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .check-mark {
    display: inline-block; /* Add this line */
    font-size: 16px;
    color: #4CAF50; /* Green color for the check mark */
  }
</style>
{% endblock %}



<!-- BODY -->
{% block content %}

<!-- Components -->
{% include 'vuetify_components/navbar.html' %}

<!-- Index Vue App -->
<div id="monai_segmentation_app">
    <v-app>
        <navbar-tag></navbar-tag>
      <v-main>
          <v-container>
            <h1>
              Monai Segmentation Task for Image List [[ list_name ]] | On Image
              <span
                v-if="images.length != 0"
                >[[ this.task.value.current_idx + 1 ]] of [[ this.images.length ]]
              </span>
            </h1>
            
            <!-- Alert -->
            <v-alert
              title="Info"
              color="blue"
              elevation="4"
              type="info"
              v-if="alert_info != null"
            >
              [[ alert_info ]]
            </v-alert>
            <v-alert
              title="Error"
              color="red"
              elevation="4"
              type="error"
              v-if="alert_error != null"
            >
              [[ alert_error ]]
            </v-alert>

            <v-row no-gutters>
              <v-col ref="wtf"
                cols="12"
                lg="8"
              >

                <div ref="canvases_parent_div" class="parent">

                  <canvas
                    ref="image"
                    class="image"
                    :style="{ border: borderImage }"
                  ></canvas>

                  <canvas
                    @mousedown="startBrushing"
                    @mousemove="brush"
                    @mouseup="stopBrushing"
                    ref="segmentation"
                    class="segmentation"
                    :style="{ border: borderSegmentation, opacity: 0.5, display: segmentation_image.display, 'z-index': segmentation_z_index}"
                  ></canvas>

                  <canvas
                    ref="coco"
                    class="coco"
                    :style="{ border: borderCoco, display: polygonDisplay, 'z-index': polygons_z_index}"
                  ></canvas>

                </div>
                
                <!-- Debugging with test canvas -->
                <!-- <canvas
                  ref="testcanvas"
                  style="width: 772px; height: 671px; border: 1px; border-style: solid;"
                  width="500"
                  height="435"
                ></canvas> -->


              </v-col>

              <v-col
              cols="12"
              lg="4"
              >

                <!-- Tools -->
                <!--https://codepen.io/zed_at_home/pen/LYpWyEM-->
                <v-form v-if="tool_set" action="/task_result" method="post" ref="form">
                  <v-row no-gutters>
                    <v-col
                    cols="12"
                    lg="6"
                    >
                      <!-- Monai Label Buttons and Tools -->
                      <div>
                        <v-btn @click="performInference">
                          Perform_Inference
                          <div v-if="inferenceLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="inferenceDoneTraining" class="check-mark">✔</div>
                        </v-btn>

                        <v-btn @click="saveLabel">
                          Save_To_MonaiLabel
                          <div v-if="saveLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="saveDoneTraining" class="check-mark">✔</div>
                        </v-btn>
                        
                        <v-btn @click="trainOnLabels">
                          Train_On_Labels
                          <div v-if="trainLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="trainDoneTraining" class="check-mark">✔</div>
                        </v-btn>

                        <v-btn @click="hideCanvas">
                          [[ hideBrushButtonText ]]
                          <v-icon>[[ segmentation_image.display === '' ? 'mdi-eye-outline' : 'mdi-eye-off' ]]</v-icon>
                        </v-btn>
                        <!-- Brush size adjustment -->
                        <label>Brush Size:</label>
                        <input type="range" v-model="brushSize" min="1" max="50" />
                        <v-btn @click="hidePolygon">
                          [[ hidePolygonButtonText ]]
                          <v-icon>[[ polygonDisplay === '' ? 'mdi-eye-outline' : 'mdi-eye-off' ]]</v-icon>
                        </v-btn>
                        <v-btn ref="toggleBrushPolygonButton" @click="toggleBrushPolygon">
                          [[ toggleBrushPolygonButtonText ]]
                        </v-btn>
                        <v-btn @click="mergePolygonsToBrushCanvas">
                          Merge Canvases to Brush
                        </v-btn>
                        <!-- <v-btn @click="toggle_brushing">
                          Test
                        </v-btn> -->


                      </div>

                    </v-col>
                  </v-row>  
                  <v-row no-gutters>
                    <v-col
                    cols="12"
                    lg="6"
                    >
                      <!-- Monai Label Buttons and Tools -->
                      <div
                        v-for="(checkbox_category, index_checkbox_category) in tool_set.checkbox_categories"
                        :key="checkbox_category['category_id']"
                      >
                        <p>[[ checkbox_category['category_id'] ]]</p>

                        <v-checkbox
                          
                          v-for="(checkbox, indexCheckbox) in checkbox_category['checkboxes']"
                          :key="checkbox['checkbox_id']"
                          v-model="result.checkbox_categories[index_checkbox_category].checkboxes[indexCheckbox].checked"
                          :label="`${result.checkbox_categories[index_checkbox_category].checkboxes[indexCheckbox].checked.toString()}`"
                          color="red"
                          hide-details
                        ></v-checkbox>

                      </div>
                      <v-radio-group
                        v-for="(radio_button_category, index_radio_category) in tool_set.radio_button_categories"
                        :key="radio_button_category['category_id']"
                        v-model="result.radio_button_categories[index_radio_category].selected"
                      >
                        <p>[[ radio_button_category['category_id'] ]]</p>
                        <v-radio
                          v-for="(radio_button, index_radio_button) in radio_button_category['buttons']"
                          :key="radio_button['button_id']"
                          :label="`${result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id}`"
                          :value="`${result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id}`"                       
                          @click="toggleBrushPolygon(result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id)"
                        ></v-radio>

                      </v-radio-group>
                    </v-col>
                    <v-col
                    cols="12"
                    lg="6"
                    >
                      <v-container>
                        <v-list dense>
                          <v-list-item-group>
                          <!-- If we need to model the selection later -->
                          <!-- <v-list-item-group v-model="selectedAnnotation"> -->
                            <v-list-item
                              v-for="(annotation, index) in coco_annotations"
                              :key="annotation.id"
                            >
                              <v-list-item-content>
                                <v-list-item-title>ID: [[ annotation.id ]]</v-list-item-title>
                                <v-list-item-subtitle>Area: [[ annotation.area ]]</v-list-item-subtitle>
                              </v-list-item-content>
                              <v-list-item-action>
                                <v-btn icon @click="deleteAnnotation(index)">
                                  <v-icon>mdi-delete</v-icon>
                                </v-btn>
                              </v-list-item-action>
                            </v-list-item>
                          </v-list-item-group>
                        </v-list>
                      </v-container>
                    </v-col>

                  </v-row>
                  <v-row no-gutters>
                    <div
                      v-for="(text_input_category, index_text_input_category) in tool_set.text_input_categories"
                      :key="text_input_category['category_id']"
                    >
                      <p>[[ text_input_category.category_id ]]</p>
                      <v-textarea
                        v-for="(text_input, index_text_input) in text_input_category['text_inputs']"
                        :key="text_input['text_input_id']"
                        v-model="result.text_input_categories[index_text_input_category].text_inputs[index_text_input].message"
                        :label="`${result.text_input_categories[index_text_input_category].text_inputs[index_text_input].text_input_id}`"
                      ></v-textarea>

                    </div>

                  </v-row>
                  <!--  -->

                  <v-btn
                    class="mr-4"
                    @click="submit"
                  >
                    submit
                  </v-btn>
                  <v-btn @click="clear">
                    clear
                  </v-btn>
                  <v-btn @click="resetToPreviousResult">
                    Go Back One Image
                  </v-btn>


                </v-form>

              </v-col>

              </v-row>

            </v-container>
      </v-main>
    </v-app>
</div>

{% endblock %}



{% block js_scripts %}

<script>

var monai_segmentation_app =new Vue({
    el: '#monai_segmentation_app',
    vuetify: new Vuetify(),

    data: () => ({
      app: "monaiSegmentation",
      user: "{{ task.user }}",
      list_name: "{{ task.list_name }}",
      monaiLabelPort: 8000,
      images: [],
      // Image
      translatePos: {x:0,y:0},
      image: {
        image_id: null, 
        base64: null
        // base64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAIAAABEtEjdAAAC7UlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwYdEkAAXvqzcMAAAAASUVORK5CYII="
      },
      imageWidth: 0,
      imageHeight: 0,
      canvasWidth: 0, // These are the internal pixels; try to keep consistent with polygons and should match imageWidth
      canvasHeight: 0, // These are the internal pixels; try to keep consistent with polygons and should match imageHeight
      aspectRatio: null, // important for dependent canvases
      borderImage: "0px green solid", /* for debugging */
      // Segmentation
      segmentation_image: {image_id: null, base64: null, display:""},
      borderSegmentation: "0px green solid", /* for debugging */
      segmentation_z_index: 0,
      //// Edit Segmentation
      isBrushing: false,
      brushSize: 10, // Default brush size
      // Coco polygons
      // coco_annotations: [{
      //   "segmentation": [[150.0,100.0, 150.0,250.0, 300.0,250.0, 400.0,175.0, 300.0,100.0]],
      //   "area": 22500,
      //   "iscrowd": 0,
      //   "image_id": 324158,
      //   "bbox":[0.0,0.0,350,400],
      //   "category_id": 1,
      //   "id": 11111111111111,
      // }],
      coco_annotations: [],
      borderCoco: "1px red solid", /* for debugging */
      hidePolygonButtonText: "Hide Polygon Canvas",
      polygonDisplay: "",
      polygons_z_index: 1,
      // Hide Button
      hideBrushButtonText: "Hide Brush Canvas",
      task: null,
      tool_set: null,
      result: null,
      alert_info: null,
      alert_error: null,
      toggleBrushPolygonButtonText: "Select Brush",
      // Spinners
      //// Inference
      inferenceLoading: false,
      inferenceDoneTraining: false,
      //// Save Image and Label to MonaiLabel
      saveLoading: false,
      saveDoneTraining: false,
      //// Training
      trainLoading: false,
      trainIntervalId: null,
      trainDoneTraining: false,
      jobCompleted: false
    }),

    delimiters: ['[[',']]'],
    // watch: {
    //   // Watch the entire array of radio_button_categories for deep changes
    //   'result.radio_button_categories': {
    //     handler: function (newValues, oldValues) {
    //       for (let i = 0; i < newValues.length; i++) {
    //         if (newValues[i].selected !== oldValues[i].selected) {
    //           // Do something when a selection is made
    //           this.onSelectionChange(i, newValues[i].selected);
    //         }
    //       }
    //     },
    //     deep: true, // This is necessary to watch inside the array for object changes
    //   },
    // },
    async mounted() {
        configuration = await this.getConfiguration()
        this.DNS = configuration.DNS;
        this.SSL = configuration.SSL;
        this.IMAGES_DB = configuration.IMAGES_DB;
        this.DB_PORT = configuration.DB_PORT;
        this.HTTP_PORT = configuration.HTTP_PORT;
        this.ADMIN_PARTY = configuration.ADMIN_PARTY;
        this.USER_INFO = configuration.USER_INFO;
        await this.getTask(this.app, this.user, this.list_name);
        if (this.task.value.completed){
          this.alert_info = "This task is completed"
          setTimeout(()=>{this.alert_info = null}, 2000)
          setTimeout(()=>{window.location.replace(this.URLS.taskList);}, 2000)
        }else{
          await this.getImageList();
          this.getTools(this.app, this.task.value.tool_set)
          // Get image
          this.image.image_id = this.images[this.task.value.current_idx]
          this.image['base64'] = await this.getBase64DataOfImageFromCouch(this.image.image_id)
          this.displayCanvasImage(current_image=this.task.value.current_idx);
          this.displayBrushImage(current_image=this.task.value.current_idx);
          this.drawAnnotations();
          this.initCoco();
          // this.initCanvasZoomTools();

          this.resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
              const {width} = entry.contentRect;
              const newHeight = width / this.aspectRatio; // Calculate the new height based on the aspect ratio
              // This is the trick right here.
              // Aspect ratio is the secret weapon
              current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
              this.$refs['canvases_parent_div'].style.width = `${current_working_width}px`
              this.$refs['canvases_parent_div'].style.height = `${current_working_width/(this.aspectRatio === null ? 1 : this.aspectRatio)}px`
            }
          });
          this.resizeObserver.observe(this.$refs['canvases_parent_div']); // Observe the size of the canvas parent div         

        }
    },

    computed: {
      // General
      URLS() {
          return {
              // old ${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}
              configuration: "/configuration",
              monaiSegmentationApp: `/monaiSegmentationApp/${this.user}/${this.list_name}`,
              getTask: `/get_task/${this.app}/${this.user}/${this.list_name}`,
              taskList: `/tasksList`,
              getToolSet: `/get_toolset`,
              getImageList: `/get_image_monai_segmentation_lists`,
              taskResult: `/task_result`,
              resetToPreviousResult: `/reset_to_previous_result`,
              // MonaiLabel URLS
              // old ${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.monaiLabelPort}
              activeLearning: `http://${this.DNS}:${this.monaiLabelPort}/activelearning/last`,
              performInference: `http://${this.DNS}:${this.monaiLabelPort}/infer/SegformerBundle`,
              uploadImage: `http://${this.DNS}:${this.monaiLabelPort}/datastore/image`,
              saveLabel: `http://${this.DNS}:${this.monaiLabelPort}/datastore/label`,
              trainOnLables: `http://${this.DNS}:${this.monaiLabelPort}/train/SegformerBundle`,
              trainStatus: `http://${this.DNS}:${this.monaiLabelPort}/train/?all=false&check_if_running=false`
          }
      },
    },

    methods: {
      // toggle_brushing(){
      //   this.isBrushing ? false : true

      // },
      initCanvasZoomTools(){
        MS = this;
        var canvas = this.$refs.image;
        var startDragOffset = {};
        var mouseDown = false;
        // add event listeners to handle screen drag
        canvas.addEventListener("mousedown", function(evt) {
          mouseDown = true;
          startDragOffset.x = evt.clientX - MS.translatePos.x;
          startDragOffset.y = evt.clientY - MS.translatePos.y;
        });

        canvas.addEventListener("mouseup", function(evt) {
          mouseDown = false;
        });

        canvas.addEventListener("mouseover", function(evt) {
          mouseDown = false;
        });

        canvas.addEventListener("mouseout", function(evt) {
          mouseDown = false;
        });

        canvas.addEventListener("mousemove", function(evt) {
          if (mouseDown) {
            MS.translatePos.x = evt.clientX - startDragOffset.x;
            MS.translatePos.y = evt.clientY - startDragOffset.y;
            // add scale soon
            MS.displayCanvasImage(MS.current_image, translatePos=MS.translatePos);
            MS.displayBrushImage(MS.current_image, translatePos=MS.translatePos);
            MS.drawAnnotations(MS.current_image, translatePos=MS.translatePos);
          }
        });

      },
      mergePolygonsToBrushCanvas(){
        // Get the canvas elements
        var cocoCanvas = this.$refs['coco'];
        var segmentationCanvas = this.$refs['segmentation'];

        // Get the 2D contexts of the canvases
        var cocoContext = cocoCanvas.getContext('2d');
        var segmentationContext = segmentationCanvas.getContext('2d');
        segmentationContext.globalCompositeOperation = "source-over";
        
        // Here, you need to access the polygons data from the 'coco' canvas.
        // This will depend on how you're storing the drawn polygons.
        // Assuming you have an array of polygon points:
        var coco_annotations = this.coco_annotations; // Your polygons data structure
        // Clear the segmentation canvas if needed
        // segmentationContext.clearRect(0, 0, segmentationCanvas.width, segmentationCanvas.height);
        
        // Iterate over the polygons and draw them on the segmentation canvas
        coco_annotations.forEach(segmentation => {
          const points = segmentation.segmentation;
          if (points.length > 0) {
            segmentationContext.beginPath();
            segmentationContext.fillStyle = `#ff0000`;
            segmentationContext.moveTo(points[0], points[1]);
            for (let i = 2; i < points.length; i += 2) {
              segmentationContext.lineTo(points[i], points[i + 1]);
            }
            segmentationContext.closePath();
            segmentationContext.fill(); // Or use .stroke() if you just want the outline
            // Save to segmentation_image.base64
            this.segmentation_image.base64 = segmentationCanvas.toDataURL('image/png')
            }
        });

        // Optionally clear the 'coco' canvas
        // cocoContext.clearRect(0, 0, cocoCanvas.width, cocoCanvas.height);
      },
      deleteAnnotation(index) {
        // Confirm with the user before deleting
        if (confirm(`Are you sure you want to delete annotation with ID ${this.coco_annotations[index].id}?`)) {
          // Remove the annotation from the array
          this.coco_annotations.splice(index, 1);
          this.drawAnnotations()
        }
      },
      initCoco(){
        MS = this;
        const canvas = this.$refs['coco'];
        const ctx = canvas.getContext('2d');
        // Load the annotations for the image
        // var cocoAnnotations = this.coco_annotations;
        let currentSegmentation = [];
        // Create an array to store draggable points (vertices)
        const vertices = [];

        // Flag to track whether the user is currently drawing a polygon
        let isDrawing = false;

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            // Enter key saves the current polygon (if one is being drawn)
            if (isDrawing && vertices.length > 0) {
              isDrawing = false;
              points = currentSegmentation.segmentation
              for (let i = 0; i < points.length; i += 2) {
                // points and data at this point should be real relative to full size image
                currentSegmentation.segmentation[i] = points[i] - MS.translatePos.x
                currentSegmentation.segmentation[i+1] = points[i+1] - MS.translatePos.y
              }
              this.coco_annotations.push(currentSegmentation); // Store the current polygon
              vertices.length = 0; // Clear the vertices
              this.drawAnnotations(MS.current_image, translatePos=MS.translatePos);
            }
            event.preventDefault(); // Prevent the default behavior of the Enter key
          }
        });

        canvas.addEventListener('mousedown', (event) => {
          const x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
          const y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked
          const x = event.clientX - canvas.getBoundingClientRect().left;
          const y = event.clientY - canvas.getBoundingClientRect().top;
          // Check if a vertex was clicked (within a certain radius)
          const clickedVertex = vertices.find((vertex) => {
            // const distance = Math.sqrt((vertex.x - x) ** 2 + (vertex.y - y) ** 2); // original
            const distance = Math.sqrt((vertex.translatedX - x*x_scaler) ** 2 + (vertex.translatedY - y*y_scaler) ** 2);
            return distance < 15; // Adjust the radius as needed for your click detection
          });

          if (clickedVertex) {
            // Clicked on an existing vertex, make it draggable
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            function onMouseMove(event) {
              const newX = event.clientX - canvas.getBoundingClientRect().left;
              const newY = event.clientY - canvas.getBoundingClientRect().top;
              // clickedVertex.x = newX; // original
              clickedVertex.translatedX = newX*x_scaler;
              // clickedVertex.y = newY; // original
              clickedVertex.translatedY = newY*y_scaler;
              drawVertices(translatePos=MS.translatePos);
            }

            function onMouseUp() {
              canvas.removeEventListener('mousemove', onMouseMove);
              canvas.removeEventListener('mouseup', onMouseUp);
            }
          } else {
            newX = x*x_scaler
            newY = y*y_scaler
            if (!isDrawing) {
              // Clicked outside existing vertices, add a new point
              isDrawing = true;
              translatedX = newX
              translatedY = newY
              const newVertex = { translatedX, translatedY };
              vertices.push(newVertex);
            } else {
              // Continue adding vertices to the current polygon
              translatedX = newX
              translatedY = newY
              const newVertex = { translatedX, translatedY };
              vertices.push(newVertex);
            }
            // Redraw the entire canvas with updated points
            drawVertices(translatePos=MS.translatePos);
          }
        });

        // Add a keyboard event listener to listen for Ctrl+Z keypress
        document.addEventListener('keydown', (event) => {
          if (event.ctrlKey && event.key === 'z') {
            // Check if there are vertices to delete
            if (vertices.length > 0) {
              // Remove the last vertex
              vertices.pop();
              // Redraw the annotations with the updated vertices
              drawVertices(translatePos=MS.translatePos);
            }
          }
        });

        function calculateArea(segmentation) {
          // Implement a function to calculate the area of a segmentation.
          // You can use a formula or algorithm to calculate the area based on the segmentation points.
          // This depends on your specific requirements.
          return 100
        }

        function calculateBoundingBox(segmentation) {
          // Implement a function to calculate the bounding box of a segmentation.
          // You can find the minimum and maximum x and y coordinates in the segmentation points.
          // This depends on your specific requirements.
          return [0.0,0.0, 0.0,0.0]
        }
        
        function generateUniqueId() {
          // Implement a function to generate a unique ID for each segmentation.
          // You can use a timestamp, a random number generator, or any other method to ensure uniqueness.
          // This depends on your specific requirements.
          return Date.now()
        }

        function drawVertices(translatePos={x:0,y:0}) {
          ctx.clearRect(0, 0, canvas.width, canvas.height); // I'm concerned here
          // ctx.translate(-translatePos.x, -translatePos.y)
          MS.drawAnnotations(MS.current_image, translatePos=MS.translatePos)
          const x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
          const y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked
          // Draw existing vertices
          ctx.fillStyle = 'blue'; // Set the vertex color
          // ctx.beginPath(); ctx.arc(0,0, 5, 0, 2 * Math.PI); ctx.fill();
          // ctx.beginPath(); ctx.arc(0,100, 5, 0, 2 * Math.PI); ctx.fill();
          // ctx.beginPath(); ctx.arc(100,100, 5, 0, 2 * Math.PI); ctx.fill();
          // ctx.beginPath(); ctx.arc(100,0, 5, 0, 2 * Math.PI); ctx.fill();
          vertices.forEach((vertex) => {
            ctx.beginPath();
            ctx.arc(vertex.translatedX, vertex.translatedY, 5, 0, 2 * Math.PI);
            ctx.fill();
          });

          // Draw the polygon based on the vertices
          ctx.fillStyle = 'rgba(0, 255, 0, 0.10)'; // Transparent (Green)
          ctx.strokeStyle = 'rgba(0, 255, 0, 1)'; // Set the line color (Green)
          ctx.lineWidth = 1; // Set the line width
          ctx.beginPath();
          if (vertices.length > 0) {
            ctx.moveTo(vertices[0].translatedX, vertices[0].translatedY);
            vertices.forEach((vertex) => {
              ctx.lineTo(vertex.translatedX, vertex.translatedY);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
          ctx.stroke();

          // Update cocoAnnotations based on vertices
          const segmentation = vertices.map((vertex) => [vertex.translatedX, vertex.translatedY]);
          const flattenedSegmentation = vertices.reduce((acc, vertex) => {
            acc.push(vertex.translatedX, vertex.translatedY);
            return acc;
          }, []);
          const newSegmentation = {
            segmentation: flattenedSegmentation,
            area: calculateArea(segmentation),
            iscrowd: 0,
            image_id: MS.image.image_id, // Set the image ID as needed
            bbox: calculateBoundingBox(segmentation),
            category_id: 1, // Set the category ID as needed
            id: generateUniqueId(), // Generate a unique ID for the segmentation
          };
          currentSegmentation = newSegmentation;
        }
      },
      drawAnnotations(recursion_base_case=0, translatePos={x:0,y:0}) {
        const coco = this.$refs['coco'];
        MS = this;
        // recursive retry
        if (recursion_base_case === 3){
            if (this.aspectRatio === null){
              this.alert_error = "On third retry to set size of coco canvas and am terminating. Check you are loading an image correctly as that sets aspectRatio which is what we don't have."
              setTimeout(()=>{this.alert_error = null}, 2000)
            }
        } else if (this.aspectRatio === null){
          for (let i=1; i<=3; i++){
            setTimeout(()=>{
              this.drawAnnotations(recursion_base_case=i);
            }, 100*(i))
          }
        } else {
          coco.width = MS.imageWidth
          coco.height = MS.imageHeight
          const coco_ctx = coco.getContext('2d');
          coco_ctx.save() // to preserve state for drawing verticies (live annotation object being created)
          coco_ctx.translate(translatePos.x, translatePos.y)
          // coco_ctx.clearRect(0, 0, MS.imageWidth, MS.imageHeight);
          // Load the annotations for the image
          var cocoAnnotations = this.coco_annotations;
          // Draw existing segmentations
          if (cocoAnnotations.length > 0){
            cocoAnnotations.forEach((segmentation) => {
              // const points = segmentation.segmentation[0];
              const points = segmentation.segmentation;
              if (points.length > 0) {
                coco_ctx.fillStyle = 'rgba(255, 0, 0, 0.10)';
                coco_ctx.strokeStyle = 'rgba(255, 0, 0, 1)'; // Set the line color
                coco_ctx.lineWidth = 1; // Set the line width
                coco_ctx.beginPath();
                coco_ctx.moveTo(points[0], points[1]);
                for (let i = 2; i < points.length; i += 2) {
                  coco_ctx.lineTo(points[i], points[i + 1]);
                }
                coco_ctx.closePath();
                coco_ctx.fill();
                coco_ctx.stroke();
              }
            });
          }
          coco_ctx.restore()
        }

      },
      async getConfiguration() {
          // https://dmitripavlutin.com/javascript-fetch-async-await/
          const response = await fetch('/configuration');
          if (!response.ok) {
              const message = `An error has occured: ${response.status}`;
              throw new Error(message);
          }
          const configuration = await response.json();
          return configuration;
      },
      async getTask(app, user, list_name) {
          await fetch(this.URLS.getTask)
          .then((response) => response.json())
          .then((data) => {
            if (data.rows.length === 1){
              this.task = data.rows[0]
            }else{
              alert("more than one task or less than 1 task...debug...")
            }
          })
      },
      async getImageList() {
        let CA = this; // Classify App Vue Object
        await fetch(this.URLS.getImageList+`?key=${this.list_name}`)
        .then((response) => response.json())
        .then((data) => {
          if (data.rows.length === 1){
            this.images = data.rows[0].value.list
            if (this.images.length === 0){
              this.alert_error = "Image list has no elements."
              setTimeout(()=>{this.alert_error = null}, 2000)
            }
          }else{
            alert("more than one task or less than 1 task...debug...")
          }
        })
      },
      async displayCanvasImage(current_image, translatePos={x:0,y:0}, fromInference=false) {
        const image = new Image();
        MS = this;
        image.onload = () => {
          // Once the image is loaded, draw it onto the canvas
          MS.imageWidth = image.width;
          MS.imageHeight = image.height;
          this.aspectRatio = MS.imageWidth / MS.imageHeight;
          // First time through image load
          current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
          this.$refs['canvases_parent_div'].style.width = `${current_working_width}px`
          this.$refs['canvases_parent_div'].style.height = `${current_working_width/this.aspectRatio}px`
          
          const canvas = this.$refs['image'];
          const context = canvas.getContext('2d');
          // Zoom practice
          
          // context.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
          canvas.width = MS.imageWidth
          canvas.height = MS.imageHeight
          context.translate(translatePos.x, translatePos.y)
          context.drawImage(image, 0, 0, MS.imageWidth, MS.imageHeight);
        };
        // Set the base64 data as the source of the Image
        image.src = `${this.image.base64}`;
      },
      async displayBrushImage(current_image, translatePos={x:0,y:0}, fromInference=false, recursion_base_case=0) {
        
        const segmentation = new Image();
        MS = this;
        segmentation.onload = () => {
          console.log("segmentation onload")
          // Once the image is loaded, draw it onto the canvas
          const canvas = this.$refs['segmentation'];
          const context = canvas.getContext('2d');
          context.setTransform(1, 0, 0, 1, 0, 0);
          transform = context.getTransform()
          console.log(`${transform.e}, ${transform.f}`)
          canvas.width = MS.imageWidth
          canvas.height = MS.imageHeight
          context.translate(translatePos.x, translatePos.y)
          console.log(translatePos.x, translatePos.y)
          console.log(`${transform.e}, ${transform.f}`)
          console.log("displayBrush64: "+this.segmentation_image.base64)
          context.drawImage(segmentation, 0, 0, MS.imageWidth, MS.imageHeight);

          const testcanvas = this.$refs['testcanvas'];
          const tcontext = canvas.getContext('2d');
          tcontext.drawImage(segmentation, 0, 0, MS.imageWidth, MS.imageHeight);
        }; 
        this.segmentation_image['image_id'] = this.images[current_image]
        if (this.segmentation_image['base64'] === null){          
          // recursive retry
          if (recursion_base_case === 3){
            if (this.aspectRatio === null){
              this.alert_error = "On third retry to set size of brush canvas and am terminating. Check you are loading an image correctly as that sets aspectRatio which is what we don't have."
              setTimeout(()=>{this.alert_error = null}, 2000)
            }
          } else if (this.aspectRatio === null){
            for (let i=1; i<=3; i++){
              setTimeout(()=>{
                this.displayBrushImage(current_image=this.task.value.current_idx, recursion_base_case=i);
              }, 100*(i))
            }
          } else {
            // Create a canvas element with desired dimensions
            image_canvas = this.$refs['image'];
            // adjust parent 
            var segmentation_canvas = document.createElement('canvas');
            segmentation_canvas.width = image_canvas.width; // Set the width of the canvas
            segmentation_canvas.height = image_canvas.height; // Set the height of the canvas
            // Convert the new canvas to a base64 data URL (default format is PNG)
            this.segmentation_image.base64 = segmentation_canvas.toDataURL();
            // Send in image
            segmentation.src = `${this.segmentation_image.base64}`;
          }
        } else {
          segmentation.src = `${this.segmentation_image.base64}`;
        }
      },
      changeImageChannel(value) {
        // This function will be called when the selected radio button changes.
        // You can perform any additional actions you need here.
      },
      startBrushing(event) {
        this.isBrushing = true;
        this.brush(event); // Start brushing immediately
      },
      stopBrushing() {
        this.isBrushing = false;
        const segmentationCanvas = this.$refs['segmentation'];
      },
      brush(event) {
        if (this.isBrushing) {
          const segmentationCanvas = this.$refs['segmentation'];
          const context = segmentationCanvas.getContext('2d');
          transform = context.getTransform()
          console.log(`brush top${transform.e}, ${transform.f}`)
          const x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
          const y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked
          const x = event.offsetX;
          const y = event.offsetY;

          // Get the color value based on the selected channel
          let colorValue = 0;
          switch (this.result.radio_button_categories[0].selected) {
            case 'Erase':
              // N: #000000
              colorValue = 0;
              break;
            case 'Background':
              // B: #0000ff
              colorValue = 255;
              break;
            case 'Disc':
              // G: #00ff00
              colorValue = 255 << 8;
              break;
            case 'Cup':
              // R: #ff0000
              colorValue = 255 << 16;
              break;
            case 'Mark GA':
              // R: #ff0000
              colorValue = 255 << 16;
              break;
          }

          // Draw a circle on the segmentationCanvas with the selected color and brush size
          if(this.result.radio_button_categories[0].selected === "Erase"){
            // Set this to "remove" versus add this fillstyle
            context.globalCompositeOperation = "destination-out";
            context.fillStyle = "rgba(0,0,0,1)";
          } else {
            context.globalCompositeOperation = "source-over";
            context.fillStyle = `#${colorValue.toString(16).padStart(6, '0')}`;
          }
          context.beginPath();
          context.arc(x*x_scaler, y*y_scaler, this.brushSize / 2, 0, Math.PI * 2);
          // context.arc(x*x_scaler - MS.translatePos.x, y*y_scaler - MS.translatePos.y, this.brushSize / 2, 0, Math.PI * 2);
          context.fill();
          this.segmentation_image.base64 = segmentationCanvas.toDataURL('image/png')
          // console.log("drawBrush64: "+this.segmentation_image.base64)
          // const timage = new Image();
          // timage.onload = () => {
          //   tcanvas = this.$refs.testcanvas
          //   tcontext = tcanvas.getContext('2d');
          //   tcontext.clearRect(0, 0, MS.imageWidth, MS.imageHeight);
          //   tcontext.drawImage(timage, 0, 0, MS.imageWidth, MS.imageHeight);
          // }
          // timage.src = this.segmentation_image.base64
        }
      },
      getTools(app, tool_set) {
        fetch(this.URLS.getToolSet + `/${app}/${tool_set}`)
        .then((response) => response.json())
        .then((data) => {
          if (data.rows.length === 1){
            // Store tool_set and make results object to match
            var tool_set = data.rows[0].value.tools
            var result = JSON.parse(JSON.stringify(data.rows[0].value.tools));
            this.result = result; 
            this.tool_set = tool_set;
          }else{
            this.alert_error = "Can't find specified tool set"
            setTimeout(()=>{this.alert_error = null}, 2000)
          }
        })
      },
      async getBase64DataOfImageFromCouch(image_id) {
        // old ${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}
        const url = `/get_image/${image_id}`;

        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          const data = await response.text();
          return `data:image/png;base64,${data}`;
        } catch (error) {
          throw error; // Rethrow the error for handling in the calling function
        }
      },
      async performInference() {
        let MSA = this; // Classify App Vue Object
        this.inferenceLoading = true;
        this.inferenceDoneTraining = false;
        await this.uploadImage();
        image_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        const url = this.URLS.performInference+'?image=' + image_name + '&output=image';
        const headers = {
          'Accept': 'application/json',
        };
    
        // Create a new FormData object to handle multipart/form-data
        const formData = new FormData();
    
        // Add the parameters, empty file field, and label (if needed) to the FormData
        formData.append('params', JSON.stringify({}));
        formData.append('file', '');
        formData.append('label', '');
    
        // Send a POST request with the FormData using the fetch API
        fetch(url, {
          method: 'POST',
          headers: headers,
          body: formData,
        })
        .then(response => response.blob())
        .then(imageBlob => {
          const reader = new FileReader(); // While FileReader used for files, the api works for imageBlob data.
          reader.onloadend = function() {
            // The result contains the Base64 string
            const base64String = reader.result;
            MSA.inferenceLoading = false;
            MSA.inferenceDoneTraining = true;
            // If you need to use the Base64 string elsewhere, do it here.
            // For instance, to set it as the source of an image:
            // const imageElement = document.getElementById('myImage');
            // imageElement.src = base64String;
            MSA.segmentation_image['base64'] = base64String
            MSA.displayBrushImage(current_image=MSA.task.value.current_idx, fromInference=true); // fix later
          };
          reader.readAsDataURL(imageBlob);
        })
        .catch(error => {
          this.inferenceLoading = false;
          this.inferenceDoneTraining = false;
        });
      },
      async uploadImage() {
        // Define the URL and headers
        image_name = this.image.image_id.split('.')[0]; // Use const or let to declare the variable
        url = this.URLS.uploadImage + `?image=${image_name}`;
        headers = {
            'Accept': 'application/json',
        };

        // Create a new FormData object to handle multipart/form-data
        formData = new FormData();

        formData.append('params', JSON.stringify({}));

        // Add the image data as a blob with a "image/png" type
        formFileName = `${image_name}.png`;
        byteCharacters = atob(this.image.base64.split(',')[1]);
        byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        byteArray = new Uint8Array(byteNumbers);
        imageBlob = new Blob([byteArray], { type: 'image/png' });
        formData.append('file', imageBlob, formFileName);

        try {
            // Send a PUT request with the FormData using the fetch API
            response = await fetch(url, {
                method: 'PUT',
                headers: headers,
                body: formData,
            });
            const file = await response.json();
            // Handle the response here if needed
        } catch (error) {
        }
      },
      async saveLabel() {
        this.saveLoading = true;
        this.saveDoneTraining = false;
        await this.uploadImage();
        this.alert_info = "Saved Image"
        this.saveLoading = false;
        this.saveDoneTraining = true;
        setTimeout(()=>{this.alert_info = null}, 2000)
        // Define the URL and headers
        image_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        // image_name = "AAA"
        const url = this.URLS.saveLabel+`?image=${image_name}&tag=final`;
        const headers = {
            'Accept': 'application/json',
        };
    
        // Create a new FormData object to handle multipart/form-data
        const formData = new FormData();

        formData.append('params', JSON.stringify({}));
    
        // Add the image data as a blob with a "image/png" type
        const formFileName = `${image_name}.png`;
        const byteCharacters = atob(this.segmentation_image.base64.split(',')[1]);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const imageBlob = new Blob([byteArray], { type: 'image/png' });
        formData.append('label', imageBlob, formFileName);
    
        // Send a PUT request with the FormData using the fetch API
        fetch(url, {
            method: 'PUT',
            headers: headers,
            body: formData,
        })
        .then(response => response.json())
        .then(file => {
            // setResponseData(file);
        })
        .catch(error => {
        });
      },
      trainOnLabels() {
        this.trainLoading = true; // Set loading to true
        this.trainDoneTraining = false;
        // Define the URL and headers
        const url = this.URLS.trainOnLables + '?run_sync=false&enqueue=false';
        const headers = {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        };
    
        // Define the POST request body data
        const postData = {};
    
        // Send a POST request using the fetch API
        fetch(url, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(postData),
        })
        .then(response => response.json())
        .then(data => {
          // Start polling for job status using setInterval
          this.trainIntervalId = setInterval(this.checkJobStatus, 1000); // Adjust the interval as needed
        })
        .catch(error => {
        });
      },
      checkJobStatus() {
        // Make an API request to check the job status
        // You should implement the logic to check the status and update the loading spinner accordingly
        // For example, you can make a GET request to an endpoint that provides the job status
        MSA = this;
        fetch(this.URLS.trainStatus, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
            },
            })
            .then(response => response.json())
            .then(data => {
            if (data.status === 'DONE') {
                MSA.trainLoading = false;
                MSA.trainDoneTraining = true;
            }
            })
            .catch(error => {
            });
        // When the job is completed or has a certain status, you can stop the interval
        if (this.jobCompleted) {
          clearInterval(this.intervalId);
          this.trainLoading = false; // Set loading to false when the job is completed
        }
      },
      hideCanvas() {
        if(this.segmentation_image.display === ""){
          this.hideBrushButtonText = "Unhide Brush Canvas"
          this.segmentation_image.display = "none"
        }else{
          this.hideBrushButtonText = "Hide Brush Canvas"
          this.segmentation_image.display = ""

        }
      },
      hidePolygon() {
        if(this.polygonDisplay === ""){
          this.hidePolygonButtonText = "Unhide Polygon"
          this.polygonDisplay = "none"
        }else{
          this.hidePolygonButtonText = "Hide Polygon"
          this.polygonDisplay = ""
        }
      },
      toggleBrushPolygon(variable) {
        if(variable instanceof PointerEvent){
          // if we clicked the Select Polygon Tool button
          if (this.polygons_z_index === 0){
            this.polygons_z_index = 1
            this.segmentation_z_index = 0
            this.polygonDisplay = ""
            this.toggleBrushPolygonButtonText = 'Select Brush'
          } else {
            this.polygons_z_index = 0
            this.segmentation_z_index = 1
            this.result.radio_button_categories[0]['selected'] = "Mark GA"
            this.segmentation_image.display = ""
            this.toggleBrushPolygonButtonText = 'Select Polygon Tool'
          }
        } else {
          // if we clicked a radio button
          this.polygons_z_index = 0
          this.segmentation_z_index = 1
          this.result.radio_button_categories[0]['selected'] = variable
          this.segmentation_image.display = ""
          this.toggleBrushPolygonButtonText = 'Select Polygon Tool'
        }

      },
      // For the submit form
      submit() {
        //this.$v.$touch() // for uswe with veulidate which you haven't setup for this app
        // this.$refs.form.$el.submit() // Normal submit but we want to send results in a better organized way
        // Define the URL and headers
        let error = null;
        this.result['radio_button_categories'].forEach((v, i, a) => {
          if (v['selected'] === null){
            error = true
            this.alert_error = "You must make a selection for the radio buttons."
            setTimeout(()=>{this.alert_error = null}, 2000)
          }
        })
        segmentation_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        const headers = {
            'Accept': 'application/json',
        };
        if (!error){
          // Create a new FormData object to handle multipart/form-data
          const formData = new FormData();
          // Add the image data as a blob with a "image/png" type
          const formFileName = `${segmentation_name}.png`;
          // Save segmentation canvas to segmentation_image.base64
          var segmentationCanvas = this.$refs['segmentation'];
          this.segmentation_image.base64 = segmentationCanvas.toDataURL('image/png')
          //
          const byteCharacters = atob(this.segmentation_image.base64.split(',')[1]);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
              byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          const imageBlob = new Blob([byteArray], { type: 'image/png' });
          formData.append('image', imageBlob, formFileName);
          // Add metadata
          this.result['_id'] = `${this.task.id}-result-${this.image.image_id}`
          this.result['user'] = this.user
          this.result['list_name'] = this.task.value.list_name
          this.result['app'] = "monaiSegmentation"
          this.result['type'] = "result"
          this.result['coco_annotation'] = this.coco_annotations
          this.result['taskid'] = this.task.id
          formData.append('json', JSON.stringify(this.result));
          fetch(this.URLS.taskResult, {
            method: 'POST',
            // headers: {
            //     'Content-Type': 'application/json'
            // },
            body: formData
          })
          .then((response) => response.json())
          .then((data) => {
            window.location.replace(this.URLS.monaiSegmentationApp);
          })
        }
      },
      // This might be a relect of a copy and paste...don't think this is used
      clear() {
        this.$v.$reset()
        this.user = ''
        this.imageListName = ''
        this.imageListTypeSelect = ''
        this.taskOrder = ''
      },
      beforeDestroy() {
        if (this.resizeObserver) {
          this.resizeObserver.disconnect(); // Clean up the observer when the component is destroyed
        }
      },
      resetToPreviousResult() {
        if(this.task['value']['current_idx'] === 0){
          this.alert_error = "You're on the first image of list!"
          setTimeout(()=>{this.alert_error = null}, 2000)
          return
        }
        Task = {
          id: this.task['id'],
          key: this.task['key'],
          value: this.task['value'],
          last_result_key: this.task.id+"-"+"result"+"-"+this.images[this.task.value.current_idx-1]
        }
        const headers = {
          'Content-Type': 'application/json',
        };
        fetch(this.URLS.resetToPreviousResult+"/"+`${this.app}`, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(Task)
        })
        .then((response) => response.json())
        .then((data) => {
          if (data["deleted_result_id"] === null){
              this.alert_error = "Can't find deleted_result_id"
              setTimeout(()=>{this.alert_error = null}, 2000)
          }else{
            this.alert_info = `Deleted ${data["deleted_result_id"]}`
            setTimeout(()=>{this.alert_info = null; location.reload();}, 2000)
          }
        })
      },
    },


  })
</script>


{% endblock %}
