<!-- TEMPLATE -->
{% extends "vuetify_components/base.html" %}

<!-- TITLE -->
{% block title %}Image Classifier{% endblock %}

<!-- CSS -->
{% block custom_css %}
<style>
  canvas {
    width: 100%;
    height: auto;
  }

  .parent {
    position: relative;
    top: 0;
    left: 0;
    background-color: black;
  }
  
  .image {
    position: relative;
    top: 0;
    left: 0;
    display: block;
  }
  
  .segmentation {
    position: absolute;
    top: 0px;
    left: 0px;
  }

  .coco {
    position: absolute;
    top: 0px;
    left: 0px;
  }

  .spinner {
    display: inline-block; /* Add this line */
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    animation: spin 1s linear infinite;
  }

  .spinner-inner {
    width: 8px;
    height: 8px;
    border: 4px solid transparent;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    position: absolute;
    top: 0px;
    left: 0px;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .check-mark {
    display: inline-block; /* Add this line */
    font-size: 16px;
    color: #4CAF50; /* Green color for the check mark */
  }
</style>
{% endblock %}



<!-- BODY -->
{% block content %}

<!-- Components -->
{% include 'vuetify_components/navbar.html' %}

<!-- Index Vue App -->
<div id="monai_segmentation_app">
    <v-app>
        <navbar-tag></navbar-tag>
      <v-main>
          <v-container>
            <h1>
              Monai Segmentation Task for Image List [[ list_name ]] | On Image
              <span
                v-if="images.length != 0"
                >[[ this.task.value.current_idx + 1 ]] of [[ this.images.length ]]
              </span>
            </h1>
            
            <!-- Alert -->
            <v-alert
              title="Info"
              color="blue"
              elevation="4"
              type="info"
              v-if="alert_info != null"
            >
              [[ alert_info ]]
            </v-alert>
            <v-alert
              title="Error"
              color="red"
              elevation="4"
              type="error"
              v-if="alert_error != null"
            >
              [[ alert_error ]]
            </v-alert>

            <v-row no-gutters>
              <v-col
                cols="12"
                lg="8"
              >

                <div ref="canvases_parent_div" class="parent">

                  <canvas
                    ref="image"
                    class="image"
                    :style="{ border: borderImage }"
                  ></canvas>

                  <canvas
                    @mousedown="startBrushing"
                    @mousemove="brush"
                    @mouseup="stopBrushing"
                    ref="segmentation"
                    class="segmentation"
                    :style="{ border: borderSegmentation, opacity: 0.2, display: segmentation_image.display, 'z-index': segmentation_z_index}"
                  ></canvas>

                  <canvas
                    ref="coco"
                    class="coco"
                    :style="{ border: borderCoco, display: polygonDisplay, 'z-index': polygons_z_index}"
                  ></canvas>

                </div>

              </v-col>

              <v-col
              cols="12"
              lg="4"
              >

                <!-- Tools -->
                <!--https://codepen.io/zed_at_home/pen/LYpWyEM-->
                <v-form v-if="tool_set" action="/task_result" method="post" ref="form">
                  <v-row no-gutters>
                    <v-col
                    cols="12"
                    lg="6"
                    >
                      <!-- Monai Label Buttons and Tools -->
                      <div>
                        <!-- <v-btn @click="performInference">
                          Perform_Inference
                          <div v-if="inferenceLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="inferenceDoneTraining" class="check-mark">✔</div>
                        </v-btn>

                        <v-btn @click="saveLabel">
                          Save_To_MonaiLabel
                          <div v-if="saveLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="saveDoneTraining" class="check-mark">✔</div>
                        </v-btn>
                        
                        <v-btn @click="trainOnLabels">
                          Train_On_Labels
                          <div v-if="trainLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="trainDoneTraining" class="check-mark">✔</div>
                        </v-btn> -->

                        <v-btn @click="hideCanvas">
                          [[ hideBrushButtonText ]]
                          <v-icon>[[ segmentation_image.display === '' ? 'mdi-eye-outline' : 'mdi-eye-off' ]]</v-icon>
                        </v-btn>
                        <!-- Brush size adjustment -->
                        <label>Brush Size:</label>
                        <input type="range" v-model="brushSize" min="1" max="50" />
                        <v-btn @click="hidePolygon">
                          [[ hidePolygonButtonText ]]
                          <v-icon>[[ polygonDisplay === '' ? 'mdi-eye-outline' : 'mdi-eye-off' ]]</v-icon>
                        </v-btn>
                        <v-btn ref="toggleBrushPolygonButton" @click="toggleBrushPolygon">
                          [[ toggleBrushPolygonButtonText ]]
                        </v-btn>
                        <v-btn @click="mergePolygonsToBrushCanvas">
                          Merge Canvases to Brush
                        </v-btn>


                      </div>

                    </v-col>
                  </v-row>  
                  <v-row no-gutters>
                    <v-col
                    cols="12"
                    lg="6"
                    >
                      <!-- Monai Label Buttons and Tools -->
                      <div
                        v-for="(checkbox_category, index_checkbox_category) in tool_set.checkbox_categories"
                        :key="checkbox_category['category_id']"
                      >
                        <p>[[ checkbox_category['category_id'] ]]</p>

                        <v-checkbox
                          
                          v-for="(checkbox, indexCheckbox) in checkbox_category['checkboxes']"
                          :key="checkbox['checkbox_id']"
                          v-model="result.checkbox_categories[index_checkbox_category].checkboxes[indexCheckbox].checked"
                          :label="`${result.checkbox_categories[index_checkbox_category].checkboxes[indexCheckbox].checked.toString()}`"
                          color="red"
                          hide-details
                        ></v-checkbox>

                      </div>
                      <v-radio-group
                        v-for="(radio_button_category, index_radio_category) in tool_set.radio_button_categories"
                        :key="radio_button_category['category_id']"
                        v-model="result.radio_button_categories[index_radio_category].selected"
                      >
                        <p>[[ radio_button_category['category_id'] ]]</p>
                        <v-radio
                          v-for="(radio_button, index_radio_button) in radio_button_category['buttons']"
                          :key="radio_button['button_id']"
                          :label="`${result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id}`"
                          :value="`${result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id}`"                       
                          @click="toggleBrushPolygon(result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id)"
                        ></v-radio>

                      </v-radio-group>
                    </v-col>
                    <v-col
                    cols="12"
                    lg="6"
                    >
                      <v-container>
                        <v-list dense>
                          <v-list-item-group>
                          <!-- If we need to model the selection later -->
                          <!-- <v-list-item-group v-model="selectedAnnotation"> -->
                            <v-list-item
                              v-for="(annotation, index) in coco_annotations"
                              :key="annotation.id"
                            >
                              <v-list-item-content>
                                <v-list-item-title>ID: [[ annotation.id ]]</v-list-item-title>
                                <v-list-item-subtitle>Area: [[ annotation.area ]]</v-list-item-subtitle>
                              </v-list-item-content>
                              <v-list-item-action>
                                <v-btn icon @click="deleteAnnotation(index)">
                                  <v-icon>mdi-delete</v-icon>
                                </v-btn>
                              </v-list-item-action>
                            </v-list-item>
                          </v-list-item-group>
                        </v-list>
                      </v-container>
                    </v-col>

                  </v-row>
                  <v-row no-gutters>
                    <div
                      v-for="(text_input_category, index_text_input_category) in tool_set.text_input_categories"
                      :key="text_input_category['category_id']"
                    >
                      <p>[[ text_input_category.category_id ]]</p>
                      <v-textarea
                        v-for="(text_input, index_text_input) in text_input_category['text_inputs']"
                        :key="text_input['text_input_id']"
                        v-model="result.text_input_categories[index_text_input_category].text_inputs[index_text_input].message"
                        :label="`${result.text_input_categories[index_text_input_category].text_inputs[index_text_input].text_input_id}`"
                      ></v-textarea>

                    </div>

                  </v-row>
                  <!--  -->

                  <v-btn
                    class="mr-4"
                    @click="submit"
                  >
                    submit
                  </v-btn>
                  <v-btn @click="clear">
                    clear
                  </v-btn>
                  <v-btn @click="resetToPreviousResult">
                    Go Back One Image
                  </v-btn>


                </v-form>

              </v-col>

              </v-row>

            </v-container>
      </v-main>
    </v-app>
</div>

{% endblock %}



{% block js_scripts %}

<script>

var monai_segmentation_app =new Vue({
    el: '#monai_segmentation_app',
    vuetify: new Vuetify(),

    data: () => ({
      app: "monaiSegmentation",
      user: "{{ task.user }}",
      list_name: "{{ task.list_name }}",
      monaiLabelPort: 8000,
      images: [],
      // Image
      image: {
        image_id: null, 
        base64: null
        // base64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAIAAABEtEjdAAAC7UlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwYdEkAAXvqzcMAAAAASUVORK5CYII="
      },
      imageWidth: 0,
      imageHeight: 0,
      canvasWidth: 0,
      canvasHeight: 0,
      aspectRatio: 1,
      borderImage: "0px green solid", /* for debugging */
      // Segmentation
      segmentation_image: {image_id: null, base64: null, display:""},
      borderSegmentation: "0px green solid", /* for debugging */
      segmentation_z_index: 0,
      //// Edit Segmentation
      isBrushing: false,
      brushSize: 10, // Default brush size
      // Coco polygons
      // coco_annotations: [{
      //   "segmentation": [[150.0,100.0, 150.0,250.0, 300.0,250.0, 400.0,175.0, 300.0,100.0]],
      //   "area": 22500,
      //   "iscrowd": 0,
      //   "image_id": 324158,
      //   "bbox":[0.0,0.0,350,400],
      //   "category_id": 1,
      //   "id": 11111111111111,
      // }],
      coco_annotations: [],
      borderCoco: "1px red solid", /* for debugging */
      hidePolygonButtonText: "Hide Polygon Canvas",
      polygonDisplay: "",
      polygons_z_index: 1,
      // Hide Button
      hideBrushButtonText: "Hide Brush Canvas",
      task: null,
      tool_set: null,
      result: null,
      alert_info: null,
      alert_error: null,
      toggleBrushPolygonButtonText: "Select Brush",
      // Spinners
      //// Inference
      inferenceLoading: false,
      inferenceDoneTraining: false,
      //// Save Image and Label to MonaiLabel
      saveLoading: false,
      saveDoneTraining: false,
      //// Training
      trainLoading: false,
      trainIntervalId: null,
      trainDoneTraining: false
    }),

    delimiters: ['[[',']]'],
    // watch: {
    //   // Watch the entire array of radio_button_categories for deep changes
    //   'result.radio_button_categories': {
    //     handler: function (newValues, oldValues) {
    //       for (let i = 0; i < newValues.length; i++) {
    //         if (newValues[i].selected !== oldValues[i].selected) {
    //           console.log(`Selection changed in category ${i}:`, newValues[i].selected);
    //           // Do something when a selection is made
    //           this.onSelectionChange(i, newValues[i].selected);
    //         }
    //       }
    //     },
    //     deep: true, // This is necessary to watch inside the array for object changes
    //   },
    // },
    async mounted() {
        configuration = await this.getConfiguration()
        this.DNS = configuration.DNS;
        this.SSL = configuration.SSL;
        this.IMAGES_DB = configuration.IMAGES_DB;
        this.DB_PORT = configuration.DB_PORT;
        this.HTTP_PORT = configuration.HTTP_PORT;
        this.ADMIN_PARTY = configuration.ADMIN_PARTY;
        this.USER_INFO = configuration.USER_INFO;
        await this.getTask(this.app, this.user, this.list_name);
        if (this.task.value.completed){
          this.alert_info = "This task is completed"
          setTimeout(()=>{this.alert_info = null}, 2000)
          setTimeout(()=>{window.location.replace(this.URLS.taskList);}, 2000)
        }else{
          await this.getImageList();
          this.getTools(this.app, this.task.value.tool_set)
          // Need to get image compare list so we can get pair to display based on current_idx
          await this.displayCanvasImage(current_image=this.task.value.current_idx);
          this.drawCoco();




          this.resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
              const {width} = entry.contentRect;
              const newHeight = width / this.aspectRatio; // Calculate the new height based on the aspect ratio
              this.adjustCanvasSize(width, newHeight);
              this.canvasWidth = width
              this.canvasHeight = newHeight
            }
          });
          this.resizeObserver.observe(this.$refs['canvases_parent_div']); // Observe the size of the canvas parent div

          

        }
    },

    computed: {
      // General
      URLS() {
          return {
              configuration: "/configuration",
              monaiSegmentationApp: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/monaiSegmentationApp/${this.user}/${this.list_name}`,
              getTask: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/get_task/${this.app}/${this.user}/${this.list_name}`,
              taskList: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/tasksList`,
              getToolSet: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/get_toolset`,
              getImageList: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/get_image_monai_segmentation_lists`,
              taskResult: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/task_result`,
              resetToPreviousResult: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/reset_to_previous_result`,
              // MonaiLabel URLS
              activeLearning: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.monaiLabelPort}/activelearning/last`,
              performInference: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.monaiLabelPort}/infer/SegformerBundle`,
              uploadImage: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.monaiLabelPort}/datastore/image`,
              saveLabel: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.monaiLabelPort}/datastore/label`,
              trainOnLables: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.monaiLabelPort}/train/SegformerBundle`,
              trainStatus: `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.monaiLabelPort}/train/?all=false&check_if_running=false`
          }
      },
    },

    methods: {
      adjustCanvasSize(width, height) {
        // Adjust the intrinsic dimensions of the canvases
        const canvasList = ['image', 'segmentation', 'coco'];
        console.log('start')
        canvasList.forEach(ref => {
          var canvas = this.$refs[ref];
          var dataURL = canvas.toDataURL(); // save state if needed...just a thought so far
          canvas.width = width;
          canvas.height = height;
          console.log(canvas.width)
          console.log(canvas.height)
          // Restore the saved content
          if (ref != 'image'){
            var img = new Image();
            img.onload = function() {
                var ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
            };
            img.src = dataURL;
          } else {
            this.displayCanvasImage(this.task.value.current_idx)
          }
        });
        console.log('end')
      },
      mergePolygonsToBrushCanvas(){
        // Get the canvas elements
        var cocoCanvas = this.$refs['coco'];
        var segmentationCanvas = this.$refs['segmentation'];

        // Get the 2D contexts of the canvases
        var cocoContext = cocoCanvas.getContext('2d');
        var segmentationContext = segmentationCanvas.getContext('2d');
        
        // Here, you need to access the polygons data from the 'coco' canvas.
        // This will depend on how you're storing the drawn polygons.
        // Assuming you have an array of polygon points:
        var coco_annotations = this.coco_annotations; // Your polygons data structure
        // Clear the segmentation canvas if needed
        // segmentationContext.clearRect(0, 0, segmentationCanvas.width, segmentationCanvas.height);
        
        // Iterate over the polygons and draw them on the segmentation canvas
        coco_annotations.forEach(segmentation => {
          const points = segmentation.segmentation;
          if (points.length > 0) {
            segmentationContext.beginPath();
            segmentationContext.fillStyle = `#ff0000`;
            segmentationContext.moveTo(points[0], points[1]);
            for (let i = 2; i < points.length; i += 2) {
              segmentationContext.lineTo(points[i], points[i + 1]);
            }
            segmentationContext.closePath();
            segmentationContext.fill(); // Or use .stroke() if you just want the outline
            }
        });

        // Optionally clear the 'coco' canvas
        // cocoContext.clearRect(0, 0, cocoCanvas.width, cocoCanvas.height);
        console.log(this.coco_annotations)
      },
      deleteAnnotation(index) {
        // Confirm with the user before deleting
        if (confirm(`Are you sure you want to delete annotation with ID ${this.coco_annotations[index].id}?`)) {
          // Remove the annotation from the array
          this.coco_annotations.splice(index, 1);
          this.redrawAnnotations()
        }
        console.log(this.coco_annotations)
      },
      drawCoco(){
        const canvas = this.$refs['coco'];
        const ctx = canvas.getContext('2d');
        // Load the annotations for the image
        var cocoAnnotations = this.coco_annotations;
        let currentSegmentation = [];
        // Create an array to store draggable points (vertices)
        const vertices = [];

        // Flag to track whether the user is currently drawing a polygon
        let isDrawing = false;

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            // Enter key saves the current polygon (if one is being drawn)
            if (isDrawing && vertices.length > 0) {
              isDrawing = false;
              cocoAnnotations.push(currentSegmentation); // Store the current polygon
              console.log(cocoAnnotations)
              vertices.length = 0; // Clear the vertices
              redrawAnnotations();
            }
            event.preventDefault(); // Prevent the default behavior of the Enter key
          }
        });

        canvas.addEventListener('mousedown', (event) => {

          const x = event.clientX - canvas.getBoundingClientRect().left;
          const y = event.clientY - canvas.getBoundingClientRect().top;
          // Check if a vertex was clicked (within a certain radius)
          const clickedVertex = vertices.find((vertex) => {
            const distance = Math.sqrt((vertex.x - x) ** 2 + (vertex.y - y) ** 2);
            return distance < 5; // Adjust the radius as needed for your click detection
          });

          if (clickedVertex) {
            // Clicked on an existing vertex, make it draggable
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);

            function onMouseMove(event) {
              const newX = event.clientX - canvas.getBoundingClientRect().left;
              const newY = event.clientY - canvas.getBoundingClientRect().top;
              clickedVertex.x = newX;
              clickedVertex.y = newY;
              redrawAnnotations();
            }

            function onMouseUp() {
              canvas.removeEventListener('mousemove', onMouseMove);
              canvas.removeEventListener('mouseup', onMouseUp);
            }
          } else {
            if (!isDrawing) {
              // Clicked outside existing vertices, add a new point
              isDrawing = true;
              const newVertex = { x, y };
              vertices.push(newVertex);
            } else {
              // Continue adding vertices to the current polygon
              vertices.push({ x, y });
            }
            // Redraw the entire canvas with updated points
            redrawAnnotations();
          }
        });

        // Add a keyboard event listener to listen for Ctrl+Z keypress
        document.addEventListener('keydown', (event) => {
          if (event.ctrlKey && event.key === 'z') {
            // Check if there are vertices to delete
            if (vertices.length > 0) {
              // Remove the last vertex
              vertices.pop();
              // Redraw the annotations with the updated vertices
              redrawAnnotations();
            }
          }
        });

        function calculateArea(segmentation) {
          // Implement a function to calculate the area of a segmentation.
          // You can use a formula or algorithm to calculate the area based on the segmentation points.
          // This depends on your specific requirements.
          return 100
        }

        function calculateBoundingBox(segmentation) {
          // Implement a function to calculate the bounding box of a segmentation.
          // You can find the minimum and maximum x and y coordinates in the segmentation points.
          // This depends on your specific requirements.
          return [0.0,0.0, 0.0,0.0]
        }
        
        function generateUniqueId() {
          // Implement a function to generate a unique ID for each segmentation.
          // You can use a timestamp, a random number generator, or any other method to ensure uniqueness.
          // This depends on your specific requirements.
          return Date.now()
        }

        function redrawAnnotations() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw existing segmentations
          if (cocoAnnotations.length > 0){
            cocoAnnotations.forEach((segmentation) => {
              // const points = segmentation.segmentation[0];
              const points = segmentation.segmentation;
              if (points.length > 0) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.10)';
                ctx.strokeStyle = 'rgba(255, 0, 0, 1)'; // Set the line color
                ctx.lineWidth = 1; // Set the line width
                ctx.beginPath();
                ctx.moveTo(points[0], points[1]);
                for (let i = 2; i < points.length; i += 2) {
                  ctx.lineTo(points[i], points[i + 1]);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
              }
            });
          }

          // Draw existing vertices
          ctx.fillStyle = 'blue'; // Set the vertex color
          vertices.forEach((vertex) => {
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, 5, 0, 2 * Math.PI);
            ctx.fill();
          });

          // Draw the polygon based on the vertices
          ctx.fillStyle = 'rgba(0, 255, 0, 0.10)';
          ctx.strokeStyle = 'rgba(0, 255, 0, 1)'; // Set the line color
          ctx.lineWidth = 1; // Set the line width
          ctx.beginPath();
          if (vertices.length > 0) {
            ctx.moveTo(vertices[0].x, vertices[0].y);
            vertices.forEach((vertex) => {
              ctx.lineTo(vertex.x, vertex.y);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          }
          ctx.stroke();

          // Update cocoAnnotations based on vertices
          const segmentation = vertices.map((vertex) => [vertex.x, vertex.y]);
          
          const flattenedSegmentation = vertices.reduce((acc, vertex) => {
            acc.push(vertex.x, vertex.y);
            return acc;
          }, []);
          const newSegmentation = {
            segmentation: flattenedSegmentation,
            area: calculateArea(segmentation),
            iscrowd: 0,
            image_id: 324158, // Set the image ID as needed
            bbox: calculateBoundingBox(segmentation),
            category_id: 1, // Set the category ID as needed
            id: generateUniqueId(), // Generate a unique ID for the segmentation
          };

          currentSegmentation = newSegmentation;
        }
        console.log(this.coco_annotations)
      },
      redrawAnnotations() {
        const canvas = this.$refs['coco'];
        // canvas.width = 800;
        // canvas.height = 800;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Load the annotations for the image
        var cocoAnnotations = this.coco_annotations;

        // Draw existing segmentations
        if (cocoAnnotations.length > 0){
          cocoAnnotations.forEach((segmentation) => {
            // const points = segmentation.segmentation[0];
            const points = segmentation.segmentation;
            if (points.length > 0) {
              ctx.fillStyle = 'rgba(255, 0, 0, 0.10)';
              ctx.strokeStyle = 'rgba(255, 0, 0, 1)'; // Set the line color
              ctx.lineWidth = 1; // Set the line width
              ctx.beginPath();
              ctx.moveTo(points[0], points[1]);
              for (let i = 2; i < points.length; i += 2) {
                ctx.lineTo(points[i], points[i + 1]);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            }
          });
        }

      },
      async getConfiguration() {
          // https://dmitripavlutin.com/javascript-fetch-async-await/
          const response = await fetch('/configuration');
          if (!response.ok) {
              const message = `An error has occured: ${response.status}`;
              throw new Error(message);
          }
          const configuration = await response.json();
          return configuration;
      },
      async getTask(app, user, list_name) {
          console.log("getTask")
          await fetch(this.URLS.getTask)
          .then((response) => response.json())
          .then((data) => {
            if (data.rows.length === 1){
              this.task = data.rows[0]
            }else{
              alert("more than one task or less than 1 task...debug...")
            }
          })
      },
      async getImageList() {
        console.log("getImageList")
        let CA = this; // Classify App Vue Object
        await fetch(this.URLS.getImageList+`?key=${this.list_name}`)
        .then((response) => response.json())
        .then((data) => {
          if (data.rows.length === 1){
            this.images = data.rows[0].value.list
            if (this.images.length === 0){
              this.alert_error = "Image list has no elements."
              setTimeout(()=>{this.alert_error = null}, 2000)
            }
          }else{
            alert("more than one task or less than 1 task...debug...")
          }
        })
      },
      async displayCanvasImage(current_image, fromInference=false) {
        const image = new Image();
        const segmentation = new Image();
        MS = this;
        image.onload = () => {
          // Once the image is loaded, draw it onto the canvas
          MS.imageWidth = image.width;
          MS.imageHeight = image.height;
          this.aspectRatio = MS.imageWidth / MS.imageHeight;
          const canvas = this.$refs['image'];
          const context = canvas.getContext('2d');

          // context.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
          if(MS.canvasWidth === 0){
            context.drawImage(image, 0, 0, MS.imageWidth, MS.imageHeight);
          }else{
            context.drawImage(image, 0, 0, MS.canvasWidth, MS.canvasHeight);
          }
          
        };
        segmentation.onload = () => {
          // Once the image is loaded, draw it onto the canvas
          const canvas = this.$refs['segmentation'];
          const context = canvas.getContext('2d');
          context.drawImage(segmentation, 0, 0, MS.canvasWidth, MS.canvasHeight);
        };

        // Set the base64 data as the source of the Image
        this.image['image_id'] = this.images[current_image]
        if (this.image.base64 === null){
          this.image['base64'] = await this.getBase64DataOfImageFromCouch(this.image.image_id)
        }
        image.src = `${this.image.base64}`;
        
        // green
        // extention_orig
        this.segmentation_image['image_id'] = this.images[current_image]
        if (!fromInference){
          this.segmentation_image['base64'] = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAIAAABEtEjdAAAC7UlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwYdEkAAXvqzcMAAAAASUVORK5CYII="
        }
        segmentation.src = `${this.segmentation_image.base64}`;

      },



      changeImageChannel(value) {
        // This function will be called when the selected radio button changes.
        console.log('Selected radio button:', value);
        // You can perform any additional actions you need here.
      },
      startBrushing(event) {
        this.isBrushing = true;
        this.brush(event); // Start brushing immediately
      },
      stopBrushing() {
        this.isBrushing = false;
      },
      brush(event) {
        if (this.isBrushing) {
          const canvas = this.$refs['segmentation'];
          const context = canvas.getContext('2d');
          const x = event.offsetX;
          const y = event.offsetY;

          // Get the color value based on the selected channel
          let colorValue = 0;
          // console.log(this.result.radio_button_categories[0].selected)
          switch (this.result.radio_button_categories[0].selected) {
            case 'Erase':
              // N: #000000
              colorValue = 0;
              break;
            case 'Background':
              // B: #0000ff
              colorValue = 255;
              break;
            case 'Disc':
              // G: #00ff00
              colorValue = 255 << 8;
              break;
            case 'Cup':
              // R: #ff0000
              colorValue = 255 << 16;
              break;
            case 'Mark GA':
              // R: #ff0000
              colorValue = 255 << 16;
              break;
          }

          // Draw a circle on the canvas with the selected color and brush size
          context.fillStyle = `#${colorValue.toString(16).padStart(6, '0')}`;
          console.log(context.fillStyle)
          context.beginPath();
          context.arc(x, y, this.brushSize / 2, 0, Math.PI * 2);
          context.fill();
        }
      },
      getTools(app, tool_set) {
        console.log("getTask")
        fetch(this.URLS.getToolSet + `/${app}/${tool_set}`)
        .then((response) => response.json())
        .then((data) => {
          if (data.rows.length === 1){
            // Store tool_set and make results object to match
            var tool_set = data.rows[0].value.tools
            var result = JSON.parse(JSON.stringify(data.rows[0].value.tools));
            this.result = result; 
            this.tool_set = tool_set;
          }else{
            this.alert_error = "Can't find specified tool set"
            setTimeout(()=>{this.alert_error = null}, 2000)
          }
        })
      },
      async getBase64DataOfImageFromCouch(image_id) {
        const url = `${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}/get_image/${image_id}`;

        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          const data = await response.text();
          return `data:image/png;base64,${data}`;
        } catch (error) {
          console.error('Error fetching image:', error);
          throw error; // Rethrow the error for handling in the calling function
        }
      },
      async performInference() {
        let MSA = this; // Classify App Vue Object
        console.log('performInference')
        this.inferenceLoading = true;
        this.inferenceDoneTraining = false;
        await this.uploadImage();
        image_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        const url = this.URLS.performInference+'?image=' + image_name + '&output=image';
        const headers = {
          'Accept': 'application/json',
        };
    
        // Create a new FormData object to handle multipart/form-data
        const formData = new FormData();
    
        // Add the parameters, empty file field, and label (if needed) to the FormData
        formData.append('params', JSON.stringify({}));
        formData.append('file', '');
        formData.append('label', '');
    
        // Send a POST request with the FormData using the fetch API
        fetch(url, {
          method: 'POST',
          headers: headers,
          body: formData,
        })
        .then(response => response.blob())
        .then(imageBlob => {
          const reader = new FileReader(); // While FileReader used for files, the api works for imageBlob data.
          reader.onloadend = function() {
            // The result contains the Base64 string
            const base64String = reader.result;
            console.log('Base64:', base64String);
            MSA.inferenceLoading = false;
            MSA.inferenceDoneTraining = true;
            // If you need to use the Base64 string elsewhere, do it here.
            // For instance, to set it as the source of an image:
            // const imageElement = document.getElementById('myImage');
            // imageElement.src = base64String;
            MSA.segmentation_image['base64'] = base64String
            MSA.displayCanvasImage(current_image=MSA.task.value.current_idx, fromInference=true); // fix later
          };
          reader.readAsDataURL(imageBlob);
        })
        .catch(error => {
          this.inferenceLoading = false;
          this.inferenceDoneTraining = false;
          console.error('Error:', error);
        });
      },
      async uploadImage() {
        console.log('uploadImage');
        // Define the URL and headers
        image_name = this.image.image_id.split('.')[0]; // Use const or let to declare the variable
        url = this.URLS.uploadImage + `?image=${image_name}`;
        headers = {
            'Accept': 'application/json',
        };

        // Create a new FormData object to handle multipart/form-data
        formData = new FormData();

        formData.append('params', JSON.stringify({}));

        // Add the image data as a blob with a "image/png" type
        formFileName = `${image_name}.png`;
        byteCharacters = atob(this.image.base64.split(',')[1]);
        byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        byteArray = new Uint8Array(byteNumbers);
        imageBlob = new Blob([byteArray], { type: 'image/png' });
        formData.append('file', imageBlob, formFileName);

        try {
            // Send a PUT request with the FormData using the fetch API
            response = await fetch(url, {
                method: 'PUT',
                headers: headers,
                body: formData,
            });
            const file = await response.json();
            // Handle the response here if needed
        } catch (error) {
            console.error('Error:', error);
        }
      },
      async saveLabel() {
        console.log('saveLabel')
        this.saveLoading = true;
        this.saveDoneTraining = false;
        await this.uploadImage();
        this.alert_info = "Saved Image"
        this.saveLoading = false;
        this.saveDoneTraining = true;
        setTimeout(()=>{this.alert_info = null}, 2000)
        // Define the URL and headers
        image_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        // image_name = "AAA"
        const url = this.URLS.saveLabel+`?image=${image_name}&tag=final`;
        const headers = {
            'Accept': 'application/json',
        };
    
        // Create a new FormData object to handle multipart/form-data
        const formData = new FormData();

        formData.append('params', JSON.stringify({}));
    
        // Add the image data as a blob with a "image/png" type
        const formFileName = `${image_name}.png`;
        const byteCharacters = atob(this.segmentation_image.base64.split(',')[1]);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const imageBlob = new Blob([byteArray], { type: 'image/png' });
        formData.append('label', imageBlob, formFileName);
    
        // Send a PUT request with the FormData using the fetch API
        fetch(url, {
            method: 'PUT',
            headers: headers,
            body: formData,
        })
        .then(response => response.json())
        .then(file => {
            // setResponseData(file);
        })
        .catch(error => {
            console.error('Error:', error);
        });
      },
      trainOnLabels() {
        console.log('trainOnLabels')
        this.trainLoading = true; // Set loading to true
        this.trainDoneTraining = false;
        // Define the URL and headers
        const url = this.URLS.trainOnLables + '?run_sync=false&enqueue=false';
        const headers = {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        };
    
        // Define the POST request body data
        const postData = {};
    
        // Send a POST request using the fetch API
        fetch(url, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(postData),
        })
        .then(response => response.json())
        .then(data => {
          console.log(data)
          // Start polling for job status using setInterval
          this.trainIntervalId = setInterval(this.checkJobStatus, 1000); // Adjust the interval as needed
        })
        .catch(error => {
          console.error('Error:', error);
          setVariantName('danger')
        });
      },
      checkJobStatus() {
        // Make an API request to check the job status
        // You should implement the logic to check the status and update the loading spinner accordingly
        // For example, you can make a GET request to an endpoint that provides the job status
        MSA = this;
        fetch(this.URLS.trainStatus, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
            },
            })
            .then(response => response.json())
            .then(data => {
            if (data.status === 'DONE') {
                MSA.trainLoading = false;
                MSA.trainDoneTraining = true;
            }
            })
            .catch(error => {
            console.error('Error fetching data:', error);
            });
        // When the job is completed or has a certain status, you can stop the interval
        if (jobCompleted) {
          clearInterval(this.intervalId);
          this.trainLoading = false; // Set loading to false when the job is completed
        }
      },
      hideCanvas() {
        console.log('hideCanvas')
        if(this.segmentation_image.display === ""){
          this.hideBrushButtonText = "Unhide Brush Canvas"
          this.segmentation_image.display = "none"
        }else{
          this.hideBrushButtonText = "Hide Brush Canvas"
          this.segmentation_image.display = ""

        }
        console.log(this.polygons_z_index)
        console.log(this.segmentation_z_index)
      },
      hidePolygon() {
        console.log('hidePolygon')
        if(this.polygonDisplay === ""){
          this.hidePolygonButtonText = "Unhide Polygon"
          this.polygonDisplay = "none"
        }else{
          this.hidePolygonButtonText = "Hide Polygon"
          this.polygonDisplay = ""
        }
        console.log(this.polygons_z_index)
        console.log(this.segmentation_z_index)
      },
      toggleBrushPolygon(variable) {
        if(variable instanceof PointerEvent){
          // if we clicked the Select Polygon Tool button
          if (this.polygons_z_index === 0){
            this.polygons_z_index = 1
            this.segmentation_z_index = 0
            this.polygonDisplay = ""
            this.toggleBrushPolygonButtonText = 'Select Brush'
          } else {
            this.polygons_z_index = 0
            this.segmentation_z_index = 1
            this.result.radio_button_categories[0]['selected'] = "Mark GA"
            this.segmentation_image.display = ""
            this.toggleBrushPolygonButtonText = 'Select Polygon Tool'
          }
        } else {
          // if we clicked a radio button
          this.polygons_z_index = 0
          this.segmentation_z_index = 1
          this.result.radio_button_categories[0]['selected'] = variable
          this.segmentation_image.display = ""
          this.toggleBrushPolygonButtonText = 'Select Polygon Tool'
        }

      },
      // For the submit form
      submit() {
        //this.$v.$touch() // for uswe with veulidate which you haven't setup for this app
        // this.$refs.form.$el.submit() // Normal submit but we want to send results in a better organized way
        // Define the URL and headers
        segmentation_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        const headers = {
            'Accept': 'application/json',
        };
        // Create a new FormData object to handle multipart/form-data
        const formData = new FormData();
        // Add the image data as a blob with a "image/png" type
        const formFileName = `${segmentation_name}.png`;
        // Save segmentation canvas to segmentation_image.base64
        var segmentationCanvas = this.$refs['segmentation'];
        this.segmentation_image.base64 = segmentationCanvas.toDataURL('image/png')
        //
        const byteCharacters = atob(this.segmentation_image.base64.split(',')[1]);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const imageBlob = new Blob([byteArray], { type: 'image/png' });
        formData.append('image', imageBlob, formFileName);
        // Add metadata
        this.result['_id'] = `${this.task.id}-result-${this.image.image_id}`
        this.result['user'] = this.user
        this.result['list_name'] = this.task.value.list_name
        this.result['app'] = "monaiSegmentation"
        this.result['type'] = "result"
        this.result['coco_annotation'] = this.coco_annotations
        this.result['taskid'] = this.task.id
        formData.append('json', JSON.stringify(this.result));
        fetch(this.URLS.taskResult, {
          method: 'POST',
          // headers: {
          //     'Content-Type': 'application/json'
          // },
          body: formData
        })
        .then((response) => response.json())
        .then((data) => {
          window.location.replace(this.URLS.monaiSegmentationApp);
        })
      },
      // This might be a relect of a copy and paste...don't think this is used
      clear() {
        this.$v.$reset()
        this.user = ''
        this.imageListName = ''
        this.imageListTypeSelect = ''
        this.taskOrder = ''
      },
      beforeDestroy() {
        if (this.resizeObserver) {
          this.resizeObserver.disconnect(); // Clean up the observer when the component is destroyed
        }
      },
      resetToPreviousResult() {
        if(this.task['value']['current_idx'] === 0){
          this.alert_error = "You're on the first image of list!"
          setTimeout(()=>{this.alert_error = null}, 2000)
          return
        }
        Task = {
          id: this.task['id'],
          key: this.task['key'],
          value: this.task['value'],
          last_result_key: this.task.id+"-"+"result"+"-"+this.images[this.task.value.current_idx-1]
        }
        const headers = {
          'Content-Type': 'application/json',
        };
        fetch(this.URLS.resetToPreviousResult+"/"+`${this.app}`, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(Task)
        })
        .then((response) => response.json())
        .then((data) => {
          if (data["deleted_result_id"] === null){
              this.alert_error = "Can't find deleted_result_id"
              setTimeout(()=>{this.alert_error = null}, 2000)
          }else{
            this.alert_info = `Deleted ${data["deleted_result_id"]}`
            setTimeout(()=>{this.alert_info = null; location.reload();}, 2000)
          }
        })
      },
    },


  })
</script>


{% endblock %}
